# AUTOGENERATED! DO NOT EDIT! File to edit: 02_train.ipynb (unless otherwise specified).

__all__ = ['DCGANLoss', 'DCGANTrainer', 'ShowDCGANImgsCallback', 'dcgan_learner']

# Cell
from fastai.vision.all import *
from .data import *
from .models import *

# Cell
class DCGANLoss(nn.Module):

  def __init__(self, dcgan: nn.Module):
    super().__init__()
    store_attr()

    self.crit = BCEWithLogitsLossFlat()

  def set_input(self, noise, real): "set `self.noise` and `self.real` for future loss calculation"; self.noise,self.real = noise, real

  def forward(self, output, target):
      """
      Generator Loss
      """
      fake_image     = self.dcgan.G(self.noise)
      disc_fake_pred = self.dcgan.D(fake_image)
      self.gen_loss  = self.crit(disc_fake_pred, torch.ones_like(disc_fake_pred))

      return self.gen_loss

# Cell
class DCGANTrainer(Callback):
    """`Learner` Callback for training a DCGAN model."""
    run_before = Recorder

    def __init__(self): pass

    def _set_trainable(self, disc=False):
        """Put the generators or discriminators in training mode depending on arguments."""
        def set_requires_grad(m, rg):
            for p in m.parameters(): p.requires_grad_(rg)
        set_requires_grad(self.learn.model.G, not disc)
        set_requires_grad(self.learn.model.D, disc)
        if disc: self.opt_D.hypers = self.learn.opt.hypers

    def before_train(self, **kwargs):
        self.G = self.learn.model.G
        self.D = self.learn.model.D
        self.crit = self.learn.loss_func.crit

        if not getattr(self,'opt_G',None):
            self.opt_G = self.learn.opt_func(self.learn.splitter(nn.Sequential(*flatten_model(self.G))), self.learn.lr)
        else:
            self.opt_G.hypers = self.learn.opt.hypers
        if not getattr(self, 'opt_D',None):
            self.opt_D = self.learn.opt_func(self.learn.splitter(nn.Sequential(*flatten_model(self.D))), self.learn.lr)
        else:
            self.opt_D.hypers = self.learn.opt.hypers

        self.learn.opt = self.opt_G

    def before_batch(self, **kwargs):
        self._set_trainable()
        self._training = self.learn.model.training
        self.learn.xb = (self.learn.xb[0],self.learn.yb[0])

        self.learn.loss_func.set_input(*self.learn.xb)

    def after_step(self):
        self.opt_D.hypers = self.learn.opt.hypers

    def after_batch(self, **kwargs):
        "Discriminator training loop"
        if self._training:
            # Obtain images
            (noise, real) = self.learn.xb
            self._set_trainable(disc=True)

            noise = torch.randn(noise.shape).to('cuda')

            fake_image = self.G(noise)

            disc_fake_pred = self.D(fake_image)
            disc_fake_loss = self.crit(disc_fake_pred, torch.zeros_like(disc_fake_pred))
            disc_real_pred = self.D(real)
            disc_real_loss = self.crit(disc_real_pred, torch.ones_like(disc_real_pred))
            disc_loss      = (disc_fake_loss + disc_real_loss) / 2

            disc_loss.backward()

            self.learn.loss_func.disc_loss = disc_loss.detach().cpu()

            # Optimizer stepping
            self.opt_D.step()
            self.opt_D.zero_grad()
            self._set_trainable()

    def before_validate(self, **kwargs):
        self.G    = self.learn.model.G
        self.D    = self.learn.model.D
        self.crit = self.learn.loss_func.crit

# Cell
class ShowDCGANImgsCallback(Callback):
    "Update the progress bar with input and prediction images"
    run_after,run_valid=DCGANTrainer,False


    def __init__(self): pass

    def before_fit(self):
        self.run = not hasattr(self.learn, 'lr_finder') and not hasattr(self, "gather_preds")
        self.nb_batches = []
        self.imgs = []
        self.titles = []
        self.steps = 0
        assert hasattr(self.learn, 'progress')

    def after_batch(self):
        if (self.steps > 0) and (self.steps % 1000 == 0):
          noise = torch.randn(1, 64, 1, 1).to('cuda')

          fake_image = self.learn.model.G(noise)
          img = TensorImage(self.learn.dls.after_batch.decode(TensorImage(fake_image))[0])

          self.imgs.append(img)
          self.titles.append(f'Step {self.steps}')
          self.progress.mbar.show_imgs(self.imgs, self.titles, imgsize=5, figsize=(8, 8))

        self.steps += 1

# Cell
@delegates(Learner.__init__)
def dcgan_learner(dls:DataLoader, m:DCGAN, opt_func=Adam, show_imgs:bool=True, metrics:list=[], cbs:list=[], **kwargs):

    lms = LossMetrics(['gen_loss', 'disc_loss'])
    learn = Learner(dls, m, loss_func=DCGANLoss(m), opt_func=opt_func,
                    cbs=[DCGANTrainer, *cbs], metrics=[*lms, *[AvgMetric(metric) for metric in [*metrics]]])

    if show_imgs: learn.add_cbs(ShowDCGANImgsCallback())
    learn.recorder.train_metrics = True
    learn.recorder.valid_metrics = False
    return learn