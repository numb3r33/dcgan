# AUTOGENERATED! DO NOT EDIT! File to edit: 01_models.ipynb (unless otherwise specified).

__all__ = ['build_conv_layer', 'build_bn', 'dcgan_generator', 'build_mnist_gen_arch', 'dcgan_discriminator',
           'build_mnist_disc_arch', 'DCGAN']

# Cell
from fastai.vision.all import *

# Cell
def build_conv_layer(ch_in:int,
                     ch_out:int,
                     ks:int,
                     stride:int,
                     padding:int=0,
                     bias:bool=True,
                     transpose:bool=False,
                     mean_weight:float=0.0,
                     std_weight:float=0.02
                     ):
  if transpose:
    conv = nn.ConvTranspose2d(ch_in,
                              ch_out,
                              ks,
                              stride,
                              padding,
                              bias=bias
                              )
  else:
    conv = nn.Conv2d(ch_in,
                     ch_out,
                     ks,
                     stride,
                     padding,
                     bias=bias
                     )

  nn.init.normal_(conv.weight, mean_weight, std_weight)
  return conv

# Cell
def build_bn(ch_in:int,
             mean_weight:float=0.0,
             std_weight:float=0.02,
             bias_const:float=0.0
             ):
  bn = nn.BatchNorm2d(ch_in)
  nn.init.normal_(bn.weight, mean_weight, std_weight)
  nn.init.constant_(bn.bias, bias_const)
  return bn

# Cell
def dcgan_generator(z_dim:int,
                    ch_in:int,
                    hidden_dim:int
                    ):
  layers = []
  layers += build_mnist_gen_arch(z_dim, ch_in, hidden_dim)

  return nn.Sequential(*layers)

def build_mnist_gen_arch(z_dim:int,
                         ch_in:int,
                         hidden_dim:int
                         ):

  layers = [build_conv_layer(z_dim, hidden_dim * 4, ks=3, stride=2, bias=False, transpose=True),
            build_bn(hidden_dim * 4),
            nn.ReLU(),
            build_conv_layer(hidden_dim * 4, hidden_dim * 2, ks=4, stride=1, bias=False, transpose=True),
            build_bn(hidden_dim * 2),
            nn.ReLU(),
            build_conv_layer(hidden_dim * 2, hidden_dim,  ks=3, stride=2, bias=False, transpose=True),
            build_bn(hidden_dim),
            nn.ReLU(),
            build_conv_layer(hidden_dim, ch_in, ks=4, stride=2, bias=False, transpose=True),
            nn.Tanh()]

  return layers

# Cell
def dcgan_discriminator(ch_in:int,
                        hidden_dim:int
                        ):
  layers = []
  layers += build_mnist_disc_arch(ch_in, hidden_dim)

  return nn.Sequential(*layers)

def build_mnist_disc_arch(ch_in:int,
                          hidden_dim:int
                          ):

  out_units = 1 # since discriminator has to estimate real/fake (binary) probability
  layers = [build_conv_layer(ch_in, hidden_dim, ks=4, stride=2, bias=False),
            build_bn(hidden_dim),
            nn.LeakyReLU(negative_slope=0.2),
            build_conv_layer(hidden_dim, hidden_dim * 2, ks=4, stride=2, bias=False),
            build_bn(hidden_dim * 2),
            nn.LeakyReLU(negative_slope=0.2),
            build_conv_layer(hidden_dim * 2, 1, ks=4, stride=2, bias=False)]
  return layers

# Cell
class DCGAN(nn.Module):
  def __init__(self,
               ch_in:int,
               z_dim:int,
               gen_hidden_dim:int=64,
               disc_hidden_dim:int=16):

    super().__init__()

    self.D = dcgan_discriminator(ch_in=ch_in,
                                 hidden_dim=disc_hidden_dim)
    self.G = dcgan_generator(z_dim=z_dim,
                             ch_in=ch_in,
                             hidden_dim=gen_hidden_dim)

  def forward(self, noise, real_image):
    fake_image = self.G(noise)

    return fake_image